name: Deploy to EC2 (demo-a frontend)

on:
  push:
    branches: [ "main" ]

jobs:
  # 1️⃣ Build: 원격 서버에 배포 폴더를 준비하고 권한을 설정합니다. (변경 없음)
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup SSH key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_KEY }}

      - name: Prepare remote directory
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} '
            set -euxo pipefail
            REMOTE_USER=$(id -un)
            sudo mkdir -p /srv/demo/projects/${{ secrets.APP_NAME }}
            sudo chown -R $REMOTE_USER:$REMOTE_USER /srv/demo
            echo "✅ Directory /srv/demo/projects/${{ secrets.APP_NAME }} is ready."
          '

  # 2️⃣ Sync: GitHub의 최신 코드를 원격 서버로 동기화합니다. (변경 없음)
  sync:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup SSH key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_KEY }}

      - name: Rsync project files to EC2
        run: |
          rsync -az --delete \
            -e "ssh -o StrictHostKeyChecking=no" ./ \
            ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/srv/demo/projects/${{ secrets.APP_NAME }}/

# 3️⃣ Deploy: 동기화된 코드로 Docker 컨테이너를 실행합니다.
  deploy:
    runs-on: ubuntu-latest
    needs: sync
    steps:
      - name: Setup SSH key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_KEY }}

      - name: Forensic Diagnosis of Docker Image
        env:
          REMOTE_HOST: ${{ secrets.EC2_HOST }}
          REMOTE_USER: ${{ secrets.EC2_USER }}
          APP: ${{ secrets.APP_NAME }}
        
        run: |
          ssh -o StrictHostKeyChecking=no $REMOTE_USER@$REMOTE_HOST "
            export APP='$APP'
            
            bash -s" << 'EOF'
              set -euxo pipefail
              
              WORKDIR="/srv/demo/projects/$APP"
              IMAGE_NAME="diagnostic-image"

              echo "---- Forensic Diagnosis Started ----"
              cd "$WORKDIR"
              
              # 1. 서버에 있는 Dockerfile 내용을 다시 한번 확인합니다.
              echo "--- Step 1: Verifying Dockerfile content on server ---"
              cat Dockerfile
              echo "------------------------------------------------------"

              # 2. 이미지를 빌드합니다.
              echo "--- Step 2: Building the diagnostic image ---"
              sudo docker build -t $IMAGE_NAME .
              echo "---------------------------------------------"

              # 3. Docker가 이 이미지의 CMD를 무엇으로 인식하는지 확인합니다.
              echo "--- Step 3: Inspecting CMD recorded in the built image ---"
              sudo docker inspect $IMAGE_NAME | grep -C 3 '"Cmd":'
              echo "------------------------------------------------------------"

              # 4. 이미지 안에 직접 들어가서 파일을 확인하고, 수동으로 서버를 실행해봅니다.
              echo "--- Step 4: Manually running server inside the container ---"
              # || true 를 붙여서 내부에서 에러가 나도 워크플로우가 멈추지 않게 합니다.
              sudo docker run --rm --network demo_net $IMAGE_NAME sh -c ' \
                echo "--- Files in container root ---"; \
                ls -la; \
                echo "--- Node version ---"; \
                node -v; \
                echo "--- Trying to start server.mjs manually ---"; \
                node server.mjs; \
              ' || true
              
              echo "---- Forensic Diagnosis Finished ----"
              # 이 워크플로우는 의도적으로 실패해야 하므로, 마지막에 에러 코드를 반환합니다.
              exit 1
          EOF
